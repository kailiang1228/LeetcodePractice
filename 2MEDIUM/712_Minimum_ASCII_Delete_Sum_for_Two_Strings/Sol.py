class Solution(object):
    """Minimum ASCII Delete Sum for Two Strings."""
    def minimumDeleteSum(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: int
        """
        m, n = len(s1), len(s2)

        # 建立 DP 表格，大小為 (m+1) x (n+1)
        # 修正: 迴圈變數改用 q 避免覆蓋掉 n (s2 的長度)
        dp = [[0] * (n + 1) for q in range(m + 1)]

        # 初始化第一列 (s2 為空字串)
        for i in range(1, m + 1):
            dp[i][0] = dp[i - 1][0] + ord(s1[i - 1])
        # 初始化第一行 (s1 為空字串)
        for j in range(1, n + 1):
            dp[0][j] = dp[0][j - 1] + ord(s2[j - 1])

        # 填充 DP 表格
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i - 1] == s2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(
                        dp[i - 1][j] + ord(s1[i - 1]),  # 刪除 s1 的字元
                        dp[i][j - 1] + ord(s2[j - 1])   # 刪除 s2 的字元
                    )

        return dp[m][n]

# 模擬測試
if __name__ == "__main__":
    s = Solution()
    # [] 陣列 裡放測試字串 () 裡放兩個字串
    test_cases = [("sea", "eat"), ("delete", "leet")]

    for str1, str2 in test_cases:
        print(s.minimumDeleteSum(str1, str2))

# 231, 403

# 這題思路是要先比較兩邊字串嗎
# 只有一邊有的直接刪
# 比字母數量嗎
# 但這樣好像都刪不完整

# 一邊固定 一邊跑 從遍歷到尾
# 沒有相同的直接刪
# 有相同的站存起來 比第二位
# 直到有不同的 或完結
# 但好像也不完全

# 你的想法：「比較兩邊字串，只有一邊有的刪除，字母數量比對。」這比較接近貪婪演算法（Greedy）。
# 缺點：這無法處理「順序」問題。例如 sea 和 eat，如果你只看字母數量，你會覺得剩下的應該是 ea，但如果字串很長，中間的字母刪除與否會影響後面的匹配，貪婪演算法會因為只看當前而錯失全局最優解。

# 最好的做法 (DP)：建立一個二維表格，紀錄「當 s1 走到第 i 個字元，s2 走到第 j 個字元時，最小的刪除代價」。
# 優點：它會窮舉所有可能的刪除組合，並記住每一條路徑的最低成本，最後保證給出全局最小值。

"""
--- 簡化版思路筆記 ---

題目目標：把 s1 和 s2 刪成一樣的字串 (共同子序列)，且要讓「刪掉的字元 ASCII 總和」最小。

直觀理解 (動態規劃 DP)：
我們建立一個表格 dp[i][j]，代表「把 s1 的前 i 個字」和「s2 的前 j 個字」變一樣，最少要花多少 ASCII 成本。

怎麼填表 (面對 s1[i] 和 s2[j] 這兩個字時)：
1. 【運氣好】這兩個字一樣 (s1[i] == s2[j])：
   -> 像兩個好朋友一樣，手牽手一起保留，不用花任何刪除費！
   -> 費用直接繼承前面的結果 (dp[i-1][j-1])。

2. 【運氣不好】這兩個字不一樣：
   -> 必須強迫刪掉其中一個。我們比較「摳門」，選便宜的那個方案：
      A方案：刪掉 s1 目前這個字 (費用：原本費用 + s1目前字的ASCII)
      B方案：刪掉 s2 目前這個字 (費用：原本費用 + s2目前字的ASCII)
   -> 哪邊便宜就選哪邊 (min)。

最後右下角的格子 (dp[m][n]) 就是答案。
"""
